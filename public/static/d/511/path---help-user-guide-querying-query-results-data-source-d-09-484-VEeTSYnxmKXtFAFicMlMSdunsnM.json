{"data":{"Article":{"html":"<p>The <strong>Query Results</strong> Data Source lets you run queries against results from your other Data Sources. Use it to join data from multiple databases or perform other kinds post-processing. Redash uses an in-memory SQLite database to make this possible. As a result, queries against large result sets may fail if Redash runs out of memory. </p>\n<h3>Setup</h3>\n<p>You can enable <strong>Query Results</strong> under the <code>Data Source</code> tab of the settings menu. Setup is easy: just provide a name for the source. This is the name that will appear in the source dropdown of the query editor.</p>\n<h3>Querying</h3>\n<p><a href=\"https://sqlite.org/lang.html\">SQLite query syntax</a> should be familiar if you have worked with other SQLs. Here's an example query:</p>\n<pre><code>SELECT a.name, b.count \nFROM query_123 a \nJOIN query_456 b ON a.id = b.id\n</code></pre>\n<p>Each of your existing queries constitutes its own \"table\" to SQLite. The table name is the string <code>query_</code> concatenated with your desired Query ID, which can be found in that query's URL. So for example, a query with the URL <code>https://app.redash.io/acme/queries/49588/source</code> will have the table name <code>query_49588</code> in SQLite.</p>\n<p>{% callout warning %}\nBe careful that your table name (<code>query_49588</code> above) appears on the same line as the associated <code>FROM</code> and <code>JOIN</code> keywords. Redash can't parse it correctly otherwise.\n{% endcallout %}</p>\n<h3>Cached Query Results</h3>\n<p>When you query the <strong>Query Results</strong> Data Source, Redash executes the underlying queries first. This ensures you have recent results in the event that <a href=\"/help/user-guide/querying/scheduling-a-query\">schedule the Query Results query</a>. You can reduce the running time of <strong>Query Results</strong> queries by using <code>cached_query_</code> for your table names instead of <code>query_</code>. This tells Redash to use the cached results from the most recent execution of a given query. This reduces the number of calls to your underlying Data Sources, improving performance by using older data. You can mix both syntaxes in the same query too, as shown below:</p>\n<pre><code>SELECT a.name, b.count \nFROM query_123 a \nJOIN cached_query_456 b ON a.id = b.id\n</code></pre>\n<br>\n<h3>Query Results Permissions</h3>\n<p>Access to the <strong>Query Results</strong> Data Source is governed by the groups it's associated with <a href=\"/help/user-guide/users/permissions-groups\">like any other Data Source</a>. But Redash will also check if a user has permission to execute queries on the Data Sources the original queries use.</p>\n<p>As an example: if a user does not have access to Data Source \"A\", they will not be able to query the results of queries against Data Source \"A\". Importantly, if that user opens an existing Query Results query that pulls data from a query of Data Source \"A\", the user will be able to see the most recently cached result of that query. But they will not be able to execute the query again.</p>","frontmatter":{"permalink":null,"title":"Querying Existing Query Results","description":null,"keywords":null,"parent_category":"user-guide","category":"querying","toc":null,"layout":null,"hide_topics":null},"parent":{"__typename":"File","relativePath":"kb/user-guide/querying/query-results-data-source.md"}},"Parent":{"frontmatter":{"title":"Querying"}},"Section":{"name":"User Guide"}},"pageContext":{"category":"querying","parent_category":"user-guide","slug":"query-results-data-source"}}