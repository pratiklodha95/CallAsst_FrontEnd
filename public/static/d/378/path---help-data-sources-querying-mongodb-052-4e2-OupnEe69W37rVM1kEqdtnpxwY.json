{"data":{"Article":{"html":"<p>Write your MongoDB query as a JSON object. During execution, Redash will convert it into either a <a href=\"https://docs.mongodb.com/manual/reference/method/db.collection.find/\"><code>db.collection.find()</code></a> call or a <a href=\"https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/\"><code>db.collection.aggregate()</code></a> call. Here's how your JSON object is mapped and sent to MongoDB:</p>\n<table>\n<thead>\n<tr>\n<th>MongoDB Token</th>\n<th>Where to write in Redash</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>db</code></td>\n<td>On the data source setup screen</td>\n</tr>\n<tr>\n<td><code>collection</code></td>\n<td>Add a <code>collection</code> key in your query object</td>\n</tr>\n<tr>\n<td><code>query</code></td>\n<td>Add a <code>query</code> key in your query object</td>\n</tr>\n<tr>\n<td><code>projection</code></td>\n<td>Add a <code>fields</code> key in your query object</td>\n</tr>\n<tr>\n<td><code>.sort() method</code></td>\n<td>Add a <code>sort</code> key in your query object</td>\n</tr>\n<tr>\n<td><code>.skip() method</code></td>\n<td>Add a <code>skip</code> key in your query object</td>\n</tr>\n<tr>\n<td><code>.limit() method</code></td>\n<td>Add a <code>limit</code> key in your query object</td>\n</tr>\n<tr>\n<td><code>db.collection.count()</code> method</td>\n<td>Use a <code>count</code> key with any value in your query object</td>\n</tr>\n</tbody>\n</table>\n<p>The values you use for each key are passed unmodified as as parameters to MongoDB.</p>\n<h2>Query Examples</h2>\n<h3>Simple Query Example</h3>\n<pre><code>{\n    \"collection\": \"my_collection\",\n    \"query\": {\n        \"type\": 1\n    },\n    \"fields\": {\n        \"_id\": 1,\n        \"name\": 2\n    },\n    \"sort\": [{\n        \"name\": \"date\",\n        \"direction\": -1\n    }]\n}\n</code></pre>\n<p>An equivalent query in Javascript would be written: <code>db.my_collection.find({\"type\": 1}, {\"_id\": 1, \"name\": 2}).sort([{\"name\": \"date\",\"direction\": -1}])</code></p>\n<h3>Count Query Example</h3>\n<pre><code>{\n    \"collection\": \"my_collection\",\n    \"count\": true\n}\n</code></pre>\n<h3>Aggregation</h3>\n<p>Aggregation uses a syntax similar to the one used in PyMongo. However, to support the correct order of sorting, it uses a regular list for the “$sort” operation that converts into a SON (sorted dictionary) object before execution.</p>\n<p>Aggregation query example:</p>\n<pre><code>{\n    \"collection\": \"things\",\n    \"aggregate\": [{\n        \"$unwind\": \"$tags\"\n    }, {\n        \"$group\": {\n            \"_id\": \"$tags\",\n            \"count\": {\n                \"$sum\": 1\n            }\n        }\n    }, {\n        \"$sort\": [{\n            \"name\": \"count\",\n            \"direction\": -1\n        }, {\n            \"name\": \"_id\",\n            \"direction\": -1\n        }]\n    }]\n}\n</code></pre>\n<h3>MongoDB Extended JSON Support</h3>\n<p>We support  <a href=\"https://docs.mongodb.com/manual/reference/mongodb-extended-json/\">MongoDB Extended JSON</a> along with our own extension - <code>$humanTime</code>:</p>\n<pre><code>{\n    \"collection\": \"date_test\",\n    \"query\": {\n        \"lastModified\": {\n            \"$gt\": {\n                \"$humanTime\": \"3 years ago\"\n            }\n        }\n    },\n    \"limit\": 100\n}\n</code></pre>\n<p>It accepts a human-readable string like the above (“3 years ago”, “yesterday”, etc) or timestamps.</p>\n<p>{% callout info %}</p>\n<p>The <code>$humanTime</code> function is also needed when using <a href=\"%7B%25%20link%20_kb/user-guide/querying/query-parameters.md%20%25%7D\">Query Parameters</a> of type Date or Date/Time with MongoDB, due to the difference between the format Redash uses and the one MongoDB expects. </p>\n<p>When using a Date (or Date Range) parameter, wrap it with a <code>$humanTime</code> object: <code>{{param}}</code> becomes <code>{\"$humanTime\": \"{{param}} 00:00\"}</code> (the <code>00:00</code> suffix is needed only with Date parameters, for Date Time parameters you should skip it).</p>\n<p>{% endcallout %}</p>\n<h3>MongoDB Filtering</h3>\n<p>You can add filters to Mongo queries by projecting a column with the\n'::filter' keyword added on to the end.</p>\n<pre><code>{\n    \"collection\": \"zipcodes\",\n    \"aggregate\": [{\n        \"$project\": {\n            \"_id\": \"$_id\",\n            \"city\": \"$city\",\n            \"loc\": \"$loc\",\n            \"pop\": \"$pop\",\n            \"state::filter\": \"$state\"\n        }\n    }]\n}\n</code></pre>\n<p>The above example will show a 'State' column, and allow you to filter on this\ncolumn.</p>\n<h2>Troubleshooting</h2>\n<h3>Sort exceeded memory limit of 104857600 bytes</h3>\n<blockquote>\n<p>Sort exceeded memory limit of 104857600 bytes, but did not opt in to external sorting. Aborting operation. Pass allowDiskUse:true to opt in.</p>\n</blockquote>\n<p>In MongoDB, the in-memory sorting have a limit of 100M, to perform a large sort, you need enable <code>allowDiskUse</code> option to write data to a temporary files for sorting.</p>\n<p>To enable the <code>allowDiskUse</code> option, just add the option to your query:</p>\n<pre><code class=\"language-json\">{\n  ...\n  \"allowDiskUse\": true\n}\n</code></pre>","frontmatter":{"permalink":null,"title":"Querying MongoDB","description":null,"keywords":null,"parent_category":"data-sources","category":"querying","toc":true,"layout":null,"hide_topics":null},"parent":{"__typename":"File","relativePath":"kb/data-sources/querying-mongodb.md"}},"Parent":{"frontmatter":{"title":"Querying"}},"Section":{"name":"Data Sources"}},"pageContext":{"category":"querying","parent_category":"data-sources","slug":"mongodb"}}